//
//  Context+Loading.swift
//  CodeTemplaterr
//
//  Created by Daniel Cech on 13/09/2020.
//

import Files
import Foundation

extension Context {
    /// Adds definitions from file to the context
    func applyContext(fromFile contextFilePath: String) throws {
        let contextFile = try File(path: contextFilePath)
        let contextString = try contextFile.readAsString(encodedAs: .utf8)
        let contextData = Data(contextString.utf8)

        do {
            // make sure this JSON is in the format we expect
            guard let contextDictionary = try JSONSerialization.jsonObject(with: contextData, options: []) as? [String: Any] else {
                throw CodeTemplaterError.invalidFormatOfData(message: contextFilePath)
            }

            let fileContext = Context(dictionary: contextDictionary)
            update(withContext: fileContext)
        }
        catch {
            throw CodeTemplaterError.generalError(message: "File \(contextFilePath) is not valid JSON.")
        }
    }

    /// Loads default context from CodeTemplater.json in current directory add adds it to the context
    func applyDefaultContext() throws {
        if !Folder.current.containsSubfolder(at: "templater") {
            scriptSetup.showUsageText()
            throw CodeTemplaterError.missingTemplaterFolder
        }

        if !Folder.current.containsFile(at: "templater/CodeTemplater.json") {
            scriptSetup.showUsageText()
            throw CodeTemplaterError.missingCodeTemplaterJson
        }

        let codeTemplaterJSON = try Folder.current.file(named: "templater/CodeTemplater.json")
        try applyContext(fromFile: codeTemplaterJSON.path)

        if Folder.current.containsFile(at: "templater/CodeTemplaterPersonal.json") {
            let codeTemplaterPersonalJSON = try Folder.current.file(named: "templater/CodeTemplaterPersonal.json")
            try applyContext(fromFile: codeTemplaterPersonalJSON.path)
        }
    }

    func update(withContext context: Context) {
        for key in context.dictionary.keys {
            dictionary[key] = context.dictionary[key]
        }
    }

    func save(toFile filePath: String) throws {
        if let jsonData = try? JSONSerialization.data(
            withJSONObject: dictionary,
            options: [.prettyPrinted, .withoutEscapingSlashes]
        ) {
            try jsonData.write(to: URL(fileURLWithPath: filePath))
        }
    }
}

// MARK: - Autogenerated values

extension Context {
    /// Autogenerated values for some items in context
    func updateContextWithAutogeneratedValues() {
        // Project name is default target name
        if self[.targetName] == nil {
            self[.targetName] = self[.projectName]
        }

        self[.date] = dateFormatter.string(from: Date())
    }
}
